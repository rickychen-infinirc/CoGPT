# 2025-09-22 系統更新日誌

## 主要功能更新項目

### 繪圖模型自動識別與標籤插入功能

**問題描述**：
用戶在選擇繪圖類型的知識庫時，需要手動輸入 `@DRAW` 標籤才能使用繪圖功能，體驗不夠流暢。
* 前端無法自動區分文字模型和繪圖模型
* 用戶選擇繪圖模型後仍需手動輸入 `@DRAW` 標籤
* 切換模型時標籤狀態無法正確同步
* 頁面重新載入後狀態丟失

**解決方案**：
1. **後端數據結構完善**
   * 確保知識庫 API 返回 `model_type` 和 `selected_image_model` 字段
   * 修改角色知識庫控制器以返回完整的模型信息
2. **前端智能識別系統**
   * 根據知識庫的 `model_type` 和 `selected_image_model` 字段自動判斷是否為繪圖模型
   * 實現視覺區隔顯示不同類型的模型
3. **自動標籤管理**
   * 選擇繪圖模型時自動插入 `@DRAW` 標籤
   * 切換到文字模型時自動清除 `@DRAW` 標籤
   * 發送繪圖消息後保留 `@DRAW` 標籤以便連續使用
4. **狀態持久化**
   * 使用 localStorage 記住用戶選擇的知識庫
   * 頁面重載時自動恢復之前的選擇狀態

### 圖片生成狀態管理優化

**問題描述**：
圖片生成完成後停止按鈕未正確變回發送按鈕，導致界面狀態不一致。
* `responsing` 狀態在圖片生成完成後未重置
* WebSocket 消息處理不完整
* 用戶界面顯示錯誤的按鈕狀態

**解決方案**：
1. **完善 WebSocket 消息處理**
   * 在圖片生成完成狀態處理中重置 `responsing` 狀態
   * 添加對圖片消息的特殊處理邏輯
2. **狀態同步機制**
   * 確保前端響應狀態與後端處理狀態同步
   * 添加調試日誌以便追蹤狀態變化

---

## 修改的文件

### 後端文件
1. **Controller/dashboard/role_knowledge_base_controller.py**
   * `get_knowledge_bases_by_role_id()`：修改返回數據結構，包含 `model_type` 和 `selected_image_model` 字段
   * `get_all_admin_knowledge_bases_data()`：更新管理員知識庫數據獲取邏輯

2. **Model/KnowledgeBase.py**
   * 確認 `get_knowledge_base_by_id()` 方法返回完整字段信息
   * 表結構已包含所需的 `model_type` 和 `selected_image_model` 字段

### 前端文件
1. **src/views/TeamChatView.vue**
   * 新增模型類型判斷函數：`isDrawingModel()`, `getModelTypeIndicatorClass()`, `getModelTypeIcon()` 等
   * 實現知識庫選擇狀態監聽和自動標籤插入
   * 添加狀態持久化邏輯
   * 修改圖片生成狀態處理函數
   * 合併重複的 `onMounted` 函數

2. **src/components/chatWindow/ChatInput.vue**
   * 新增 `insertDrawMention()` 和 `clearExistingMentions()` 方法
   * 修改 `sendMessage()` 函數以保留繪圖模式下的 `@DRAW` 標籤
   * 添加 `defineExpose` 暴露方法給父組件

---

## 核心功能實現

### 模型類型視覺區隔
```javascript
// 繪圖模型顯示紫色圖標和標籤
const getModelTypeIndicatorClass = (kb) => {
  if (kb.model_type === 'image' || 
      (kb.selected_image_model && kb.selected_image_model.trim() !== '')) {
    return 'bg-purple-500 text-white'; // 紫色圓圈 + 畫筆圖標
  }
  return 'bg-blue-500 text-white'; // 藍色圓圈 + 對話圖標
};
```

### 智能標籤管理
```javascript
watch(selected_LLM_or_KB, async (newSelection, oldSelection) => {
  if (newSelection && newSelection.is_kb && newSelection.id) {
    // 保存用戶選擇
    localStorage.setItem('selected_kb_id', newSelection.id.toString());
    
    const kbData = AllKnowledgeBases.value.find(kb => kb.id === newSelection.id);
    
    if (kbData && isDrawingModel(kbData)) {
      // 自動插入 @DRAW 標籤
      nextTick(() => {
        if (chatInputRef.value) {
          chatInputRef.value.insertDrawMention();
        }
      });
    } else {
      // 清除 @DRAW 標籤
      nextTick(() => {
        if (chatInputRef.value) {
          chatInputRef.value.clearExistingMentions();
        }
      });
    }
  }
}, { deep: true });
```

### 狀態持久化恢復
```javascript
async function loadAvailableKnowledgeBases(role_id) {
  const response = await fetch_with_token(`/api/role_knowledge_bases/${role_id}`);
  if (response.ok) {
    const data = await response.json();
    if (data.status === 'success') {
      AllKnowledgeBases.value = data.data;
      
      // 嘗試從 localStorage 恢復上次選擇
      const savedKbId = localStorage.getItem('selected_kb_id');
      let targetKb = AllKnowledgeBases.value.find(kb => 
        kb.id === parseInt(savedKbId)) || AllKnowledgeBases.value[0];
      
      selected_LLM_or_KB.value = {
        id: targetKb.id, 
        name: targetKb.name, 
        is_kb: true
      };
    }
  }
}
```

### 繪圖消息標籤保留
```javascript
const sendMessage = () => {
  // 保存當前 mention 狀態
  const currentMentionType = mentionType.value;
  const isDrawMention = currentMentionType === 'DRAW';
  
  if (isDrawMention) {
    // 繪圖模式：保留 @DRAW 標籤，只清除文字內容
    const inputDiv = chatInputDivRef.value;
    const mentionTag = inputDiv.querySelector('.mention-tag-draw');
    
    if (mentionTag) {
      // 重建輸入框，保留 @DRAW 標籤
      inputDiv.innerHTML = '';
      const p = document.createElement('p');
      p.appendChild(mentionTag.cloneNode(true));
      const space = document.createTextNode('\u00A0');
      p.appendChild(space);
      inputDiv.appendChild(p);
      
      // 保持狀態
      hasMention.value = true;
      mentionType.value = 'DRAW';
      isEmpty.value = false;
    }
  } else {
    // 文字模式：完全清空
    // ... 原有清空邏輯
  }
};
```

