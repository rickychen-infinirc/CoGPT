# 2025-09-23 系統更新日誌

## 主要功能更新項目

### 1. 群組聊天 WebSocket 廣播修復

**問題描述**：
群組聊天中 AI 回覆時，只有發送者能看到流式輸出，其他用戶需要重新整理網頁才能看到 AI 的完整回覆。
* WebSocket 廣播機制無法正確分發消息給所有群組成員
* 其他用戶長時間顯示載入動畫（三個點）
* 前端消息處理邏輯對非發送者用戶阻擋了重要消息
* WebSocket 連接不穩定導致頻繁重連（error code 1005）

**解決方案**：

1. **後端廣播機制優化**
   * 修改 `ChatManager.broadcast()` 方法，增加詳細調試日誌
   * 實現流式更新僅發送給發送者，避免其他用戶收到不完整內容
   * 強制廣播 `final_update` 給所有群組成員，確保訊息完整性

2. **前端消息處理邏輯修正**
   * 修復 `handleWebSocketMessage` 中過度嚴格的狀態檢查
   * 允許 `final_update` 消息在任何狀態下都能被處理
   * 確保所有用戶都能正確重置載入狀態

3. **輪詢機制實現**
   * 新增輪詢功能作為 WebSocket 的備用方案
   * 每2秒檢查聊天歷史，檢測 AI 回覆完成狀態
   * 智能檢測連續多次無變化來判斷回覆結束

### 2. 普通對話模式實現

**問題描述**：
用戶無法發送不經過 AI 處理的普通訊息，所有訊息都會觸發 AI 回覆。

**解決方案**：
1. **知識庫選擇器擴展**
   * 在知識庫快捷列最前方添加「普通對話」選項
   * 提供視覺區隔，使用灰色圖標和特殊樣式
   * 實現狀態持久化，記住用戶選擇

2. **訊息發送邏輯調整**
   * 檢測「普通對話」模式，設置 `talk_with_ai: false`
   * 跳過 AI 處理流程，直接發送純文字訊息
   * 不設置響應狀態，避免無意義的載入動畫

### 3. AI 上下文用戶名稱優化

**問題描述**：
AI 在群組對話中無法識別不同用戶的身份，影響多人對話體驗。

**解決方案**：
1. **聊天歷史格式改進**
   * 在群組聊天歷史中加入用戶名稱前綴
   * 個人聊天也添加用戶名稱以保持一致性
   * 格式：`用戶名: 消息內容`

2. **系統提示詞增強**
   * 在系統提示詞中說明用戶名稱格式
   * 指導 AI 適當稱呼用戶並考慮多人對話上下文

---

## 修改的文件

### 後端文件

1. **Controller/dashboard/chat_controller.py**
   * `ChatManager.broadcast()`：增加調試日誌和發送結果檢查
   * `handle_group_chat()`：修改流式更新策略，實現強制 final_update 廣播
   * `handle_personal_chat()`：為個人聊天歷史添加用戶名稱
   * 群組聊天歷史處理：加入用戶名稱到消息內容中

### 前端文件

1. **src/views/TeamChatView.vue**
   * 新增普通對話選項到知識庫快捷列
   * 實現輪詢機制：`startPolling()`, `stopPolling()`
   * 修改 `sendMessage()` 函數支援普通對話模式
   * 修復 `handleWebSocketMessage()` 消息處理邏輯
   * 優化 `processChatMessage()` 中的 final_update 處理

---

## 核心功能實現

### WebSocket 廣播強化
```python
# 強制發送給所有用戶，繞過廣播限制
final_message = json.dumps({
    "id": bot_message_id,
    "sender_role": "bot",
    "message": response,
    "llm_kb_name": kb_name,
    "source_documents": source_docs,
    "timestamp": datetime.now().isoformat(),
    "mode": "final_update"
})

if f"group_{group_id}" in chat_manager.active_connections:
    for user_id_in_group, connection in chat_manager.active_connections[f"group_{group_id}"].items():
        try:
            await connection.send_text(final_message)
            print(f"成功發送 final_update 給用戶 {user_id_in_group}")
        except Exception as e:
            print(f"發送給用戶 {user_id_in_group} 失敗: {e}")
```

### 普通對話模式
```javascript
// 檢查是否選擇了"普通對話"（無模型）
if (!selected_LLM_or_KB.value.is_kb && !selected_LLM_or_KB.value.id) {
    const messageData = {
        chat_type: 'group',
        chat_id: selectedChatRoomId.value,
        message: message,
        use_kb: false,
        kb_id: null,
        talk_with_ai: false,  // 關鍵：不需要AI回覆
        mention_type: 'NORMAL',
        api_key: null
    };
    
    chatWebSocket.send(JSON.stringify(messageData));
    return; // 直接返回，不設置響應狀態
}
```

### 輪詢備用機制
```javascript
const startPolling = () => {
    pollingInterval.value = setInterval(async () => {
        if (!selectedChatRoomId.value || !responsing.value) {
            stopPolling();
            return;
        }
        
        const response = await fetch_with_token(
            `/api/chatrooms/${selectedChatRoomId.value}/history?offset=0&limit=5`
        );
        const data = await response.json();
        
        if (data.status === 'success' && data.data.length > 0) {
            const latestMessage = data.data[data.data.length - 1];
            
            if (latestMessage.sender_role === 'bot' && 
                latestMessage.message && latestMessage.message.trim() !== '') {
                // 更新前端聊天歷史
                responsing.value = false;
                stopPolling();
            }
        }
    }, 2000);
};
```

### 用戶名稱上下文
```python
# 群組聊天歷史處理
for msg in chat_history:
    if msg[3] == "user":
        username = msg[8] if len(msg) > 8 and msg[8] else "未知用戶"
        history.insert(0, {
            "role": "user", 
            "content": f"{username}: {msg[5]}"
        })
    elif msg[3] == "bot":
        history.insert(0, {"role": "bot", "content": msg[5]})

# 個人聊天歷史處理
if msg[2] == "user":
    username = get_username_by_id(user_id)
    history.append({
        "role": "user", 
        "content": f"{username}: {msg[3]}"
    })
```

### 前端消息處理修復
```javascript
// 修改前：過度嚴格的狀態檢查
if (!responsing.value && messageData.mode !== 'create' && messageData.mode !== 'update') {
    console.log(' 前端已停止，忽略部分後端消息');
    return;
}

// 修改後：允許 final_update 通過
if (!responsing.value && messageData.mode !== 'create' && 
    messageData.mode !== 'update' && messageData.mode !== 'final_update') {
    console.log(' 前端已停止，忽略部分後端消息');
    return;
}
```

這些問題將在後續版本中解決。
